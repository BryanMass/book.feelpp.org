= What is a Toolbox

{feelpp} comes with toolboxes. What are they ?

.Definition: A {feelpp} Toolbox
****
For a given set of partial differential equations for a given physics (_e.g._ xref:toolboxes:cfd:index.adoc[computational fluid dynamics]) or set of physics (_e.g._ xref:toolboxes:fsi:index.adoc[fluid structure interaction]), a {feelpp} toolbox provides:

* the configuration the set of equations through one or several (`.json`) files and (`.cfg`) files
* one or more solution strategies to solve the set of equations
****

Using the xref:what-is-a-toolbox.adoc#_json_files[JSON] and xref:what-is-a-toolbox.adoc#_cfg_files[CFG], it is possible to configure and run models by defining the relevant physical quantitiesâ€”such as material properties, loads, constraints, sources, and fluxes.

== JSON files

The Model JSON (`.json`) files allow to configure a set of partial differential equations, more precisely they define:

* [x] <<Names,Names>>
* [x] <<Models,Models>>
* [x] <<Parameters,Parameters>>
* [x] <<Materials,Materials>>
* [x] <<BoundaryConditions,Boundary conditions>>
* [x] <<PostProcessing,Post processing>>


=== Names

A model JSON file starts by giving names (long and short).
[source,json]
----
"Name": "Turek-Hron cfd2", <1>
"ShortName":"cfd2", <2>
----
<1> Name of the example, usually printed on-screen and in log files during simulations
<2> Short name of the example, it is used to create directories to store the results of the simulation of the model

NOTE: Theses names are not used currently, but it should be the case in the future.

=== Models

A section Models can appear if the toolbox has several kinds of model (typically for select the PDE used).
In most toolboxes, this section is optional and a model by default is choseen.
The latter allows to configure the set of equations associated with fluid toolbox.
[source,json]
----
"Models": <1>
{
   "equations":"Navier-Stokes" <2>
}
----
<1> Section `Models` defined by the toolbox to define the main configuration of a toolbox and in particular the set of equations to be solved
<2> toolbox specific option to define set of equations to be solved, read the toolbox manual to learn about the possible options.

=== Parameters

This section of the Model JSON file defines the parameters that may enter expressions used in the subsequent sections.

[source,json]
.Example of a `Parameters` section
----
"Parameters": <1>
    {
        "ubar":"1.0" <2>
    }
----
<1> name of the section
<2> defines a new parameter `ubar` and its associated value


=== Materials

This section of the Model JSON file defines material properties linking the Physical Entities in the mesh data structures to these properties.

.Example of Materials section
[source,json]
----
"Materials":
    {
        "Water": <1>
        {
            "physics":"fluid", <2>
            "markers":"[marker1,marker2]", <3>
            "rho":"1.0e3", <4>
            "mu":"1.0" <5>
        }
    }
----
<1> gives the name of the physical entity (here `Physical Surface`) associated to the Material.
<2> defined which kind of physics is apply in this material. This is an optional section, by default all physics are apply. The value can be also a vector of physic.
<3> defined mesh marker(s) where the material properties are applied. This is an optional section, by default the marker is take as the name <1>.
<4> density stem:[\rho] is called `rho` and is given in SI units
<5> viscosity stem:[\mu] is called `mu` and is given in SI units


=== BoundaryConditions

This section of the Model JSON file defines the boundary conditions.

[source,json]
.Example of a `BoundaryConditions` section
----
"BoundaryConditions":
    {
        "velocity":  <1>
        {
            "Dirichlet": <2>
            {
                "inlet": <3>
                {
                    "expr":"{ 1.5*ubar*(4./0.1681)*y*(0.41-y),0}:ubar:y" <4>
                },
                "wall1": <5>
                {
                    "expr":"{0,0}" <6>
                },
                "wall2": <7>
                {
                    "expr":"{0,0}" <8>
                }
            }
        },
        "fluid": <9>
        {
            "outlet": <10>
            {
                "outlet": <11>
                {
                    "expr":"0" <12>
                }
            }
        }
    }
----
<1> the field name of the toolbox to which the boundary condition is associated
<2> the type of boundary condition to apply, here `Dirichlet`
<3> the physical entity (associated to the mesh) to which the condition is applied
<4> the mathematical expression associated to the condition, note that the parameter `ubar`  is used
<5> another physical entity to which `Dirichlet` conditions are applied
<6> the associated expression to the entity
<7> another physical entity to which `Dirichlet` conditions are applied
<8> the associated expression to the entity
<9> the variable toolbox to which the condition is applied, here `fluid` which corresponds to velocity and pressure stem:[(\mathbf{u},p)]
<10> the type of boundary condition applied, here outlet or outflow boundary condition
<11> the hysical entity to which outflow condition is applied
<12> the expression associated to the outflow condition, note that it is scalar and corresponds in this case to the condition stem:[\sigma(\mathbf{u},p) \normal = 0 \normal]

=== PostProcessing
This section allows to define the output fields and quantities to be computed and saved for _e.g._ visualization.

[source,json]
.Template of a `PostProcess` section
----
"PostProcess":
{
    "Exports":
    {
        "fields":["field1","field2",...]
    },
    "Measures":
    {
        "<measure type>":
        {
            ....
        }
    }
}
----


=== Exports

The `Exports` section is implemented when you want to visualize some fields with ParaView software for example.
The entry fields should be fill with name of field availables by the toolbox used.

=== Measures

Severals quantities can be computed after each time step for transient simulation or after the solve of a stationary simulation.
The values computed are stored in a csv file format and named <toolbox>.measures.csv.
In the template of `PostProcess` section, `<measure type>` is the name given of a measure.
In next subsection, we present some types of measure that are common for all toolobox. Other types of measure are availables but depend of the toolbox used,
and the description is given in the specific toolbox documentation.

The common measure are :

* [x] <<Points,Points>>
* [x] <<Norm,Norm>>

==== Points

TODO

==== Norm

The next table presents the several norm that you can evaluate :

[separator=;]
|===
; Norm Type ; Expression

; L2 ; stem:[ \| u \|_{L^2} = \left ( \int_{\Omega} \| u \|^2 \right)^{\frac{1}{2}}]
; SemiH1 ; stem:[ | u |_{H^1} = \left ( \int_{\Omega} \| \nabla u \|^2 \right)^{\frac{1}{2}} ]
; H1 ; stem:[ \| u \|_{L^2} = \left ( \int_{\Omega} \| u \|^2 +  \int_{\Omega} \| \nabla u \|^2 \right)^{\frac{1}{2}} ]
; L2-error ; stem:[ \| u-v \|_{L^2} = \left ( \int_{\Omega} \| u-v \|^2 \right)^{\frac{1}{2}}]
; SemiH1-error ; stem:[ | u-v |_{H^1} = \left ( \int_{\Omega} \| \nabla u-\nabla v \|^2 \right)^{\frac{1}{2}} ]
; H1-error ; stem:[ \| u-v \|_{L^2} = \left ( \int_{\Omega} \| u-v \|^2 +  \int_{\Omega} \| \nabla u-\nabla v \|^2 \right)^{\frac{1}{2}} ]
|===

where stem:[\| . \|] represents the norm of the generalized inner product. The symbol `u` represents a field or an expression and `v` an expression.

The next source code show an example of Norm section with two computations of norm. The results are stored in a csv file with column named `Norm_mynorm_L2` and `Norm_myerror_L2-error`.
[source,json]
.Example of a `Norm` section
----
"Norm":
{
    "mynorm": <1>
    {
        "type":"L2", <2>
        "field":"velocity", <3>
     },
     "myerror": <4>
     {
         "type":"L2-error", <5>
         "field":"velocity", <6>
         "solution":"{2*x,cos(y)}:x:y", <7>
         "markers":"omega" <8>
     }
}
----
<1> The name associated to the first norm computation
<2> The norm type
<3> The field `u` evaluated in the norm (here the velocity field in the fluid toolbox)
<4> The name associated to the second norm computation
<5> The norm type
<6> The field `u` evaluated in the norm
<7> The expression `v` with the error norm type
<8> The mesh marker where the norm is computed (stem:[\Omega] in the previous table). This entry can be a vector of marker


NOTE: with the `H1-error` or `SemiH1-error` norm, the gradient of the solution must be given with  `grad_solution` entry. Probably this input should be automatically deduced in the near future.

Several norms can be computed by listing it in the type section : 
[source,json]
----
"type":["L2-error","H1-error","SemiH1-error"],
"solution":"{2*x,cos(y)}:x:y",
"grad_solution":"{2,0,0,-sin(y)}:x:y",
----

An expression (scalar/vector/matrix) can be also passed to evaluate the norm. But in this case, the `field` entry must be removed and this expression replace the symbol `u`.
[source,json]
----
"expr":"2*x*y:x:y"
----

NOTE: As before, in the case of `H1` or `SemiH1` norm type, the `grad_expr` entry must be given.
[source,json]
----
"grad_expr":"{2*y,2*x}:x:y"
----

All expressions can be depends of specifics symbols related to the toolboxes used. For example, in the heat toolboxes : 
[source,json]
----
"expr":"2*heat_T+3*x:heat_T:x"
----
where `heat_T` is the temperature solution computed at last solve. It can also depends of a parameter defined in the `Parameters` section of the JSON.

The quadrature order used in the norm computed can be also given if an analytical expression is used. By default, the quadrature order is 5. For example, use a quadrature order equal to 10 is done by adding :
[source,json]
----
"quad":10
----

=== An example

[source,json]
----
"PostProcess": <1>
    {
        "Exports": <2>
        {
            "fields":["velocity","pressure","pid"] <3>
        },
        "Measures": <4>
        {
            "Forces":"wall2", <5>
            "Points": <6>
            {
                "pointA": <7>
                {
                    "coord":"{0.6,0.2,0}", <8>
                    "fields":"pressure" <9>
                },
                "pointB": <10>
                {
                    "coord":"{0.15,0.2,0}", <11>
                    "fields":"pressure" <12>
                }
            }
        }
    }
----
<1> the name of the section
<2> the `Exports` identifies the toolbox fields that have to be exported for visualisation
<3> the list of fields to be exported
<4> the `Measures` section identifies outputs of interest such as
<5> `Forces` applied to a surface given by the physical entity `wall2`
<6> `Points` values of fields
<7> name of the point
<8> coordinates of the point
<9> fields to be computed at the point coordinate
<10> name of the point
<11> coordinates of the point
<12> fields to be computed at the point coordinate

Here is a   xref:examples:csm:rotating-winch/index.adoc[biele example] from the Toolbox examples.



== CFG files

The Model CFG (`.cfg`) files allow to pass command line options to {feelpp} applications. In particular, it allows to

* setup the output directory
* setup the mesh
* setup the time stepping
* define the solution strategy and configure the linear/non-linear algebraic solvers.
* other options specific to the toolbox used

[source,ini]
----
directory=toolboxes/fluid/TurekHron/cfd3/P2P1G1 <1>

[fluid] <2>
filename=$cfgdir/cfd3.json <3>

mesh.filename=$cfgdir/cfd.geo <4>
gmsh.hsize=0.03 <5>

solver=Newton <6>

pc-type=lu <7>

bdf.order=2 <8>

[ts]
time-step=0.01 <9>
time-final=10 <10>
----

<1> the directory where the results are stored
<2> the prefix of option
<3> the path of the json file
<4> the path of geo/mesh file
<5> characterist size of the mesh
<6> type of non linear solver (specific to fluid toolbox)
<7> type of preconditioner
<8> order of BDF tiem scheme (specific to fluid toolbox)
<9> time step
<10> time final

